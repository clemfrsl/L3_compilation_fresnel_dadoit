Package sc;

Helpers

lettre = [['a' .. 'z'] + ['A' .. 'Z']];
chiffre = ['0' .. '9'];
alpha = [lettre + ['_' + '$']];
alphanum = [lettre + chiffre];

Tokens

espaces = (' ' | 13 | 10)+;
commentaire= '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);
virgule = ',';
pointvirgule = ';';
nombre = chiffre+;
identif = alpha alphanum*;
parenthesegauche = '(';
parenthesedroite = ')';
crochetgauche = '[';
crochetdroit = ']';
accoladegauche = '{';
accoladedroite = '}';
egal = '=';
plus = '+';
moins = '-';
mul = '*';
div = '/';
inf = '<';
ou = '|';
et = '&';
non = '!';
lire = 'lire()'; # verifier les fonctions
ecrire = 'ecrire';
retour = 'retour';
vrai = 'vrai';
faux = 'faux';
tantque = 'tantque';
faire = 'faire';
si = 'si';
alors = 'alors';
sinon = 'sinon';

Ignored Tokens

espaces, commentaire;

Productions

// l'axiome

programme = {listedeclarationvariable}ldv {listedeclarationfonction}ldf ;
ldv = {declarationvariable}dv {listedeclarationvariablebis}ldvbis
    |;
ldvbis = virgule {declarationvariable}dv {listedeclarationvariablebis}ldvbis
    |;
dv = {typevariable}tv identif
    | {typevariable}tv identif crochetgauche nombre crochetdroit;
ldf = {declarationfonction}df {listedeclarationfonction}ldf
    |;
df = {typeoptionel}to identif parenthesegauche {listedeclarationvariable}ldv parenthesedroite {listedeclarationvariable}ldv {blocinstruction}bi;
to = tv
    |;
bi = accoladegauche {listeinstruction}li accoladedroite;
li = {instruction}i {listeinstruction}li
    |;
i = {variable}var egal {expression}exp pointvirgule
    | tantque {expression}exp faire {blocinstruction}bi
    | si {expression}exp alors {blocinstruction}bi
    | si {expression}exp alors {blocinstruction}bi sinon {blocinstruction}bi
    | retour {expression}exp pointvirgule pointvirgule
    | ecrire parenthesegauche {expression}exp parenthesedroite pointvirgule
    | identif parenthesegauche {listeexpression}lexp parenthesedroite pointvirgule;
lexp = {expression}exp {listeexpressionbis}lexpbis
    |;
lexpbis = virgule {expression}exp {listeexpressionbis}lexpbis
    |;
exp = {expression}exp ou {et}e1
    | {et}e1;
e1 = {et}e1 et {egalinf}e2
    | {egalinf}e2;
e2 = {egalinf}e2 egal {plusmoins}e3
    | {egalinf}e2 inf {plusmoins}e3
    | {plusmoins}e3;
e3 = {plusmoins}e3 plus {muldiv}e4
    | {plusmoins}e3 moins {muldiv}e4
    | {muldiv}e4;
e4 = {muldiv}e4 mul {negation}e5
    | {muldiv}e4 div {negation}e5
    | {negation}e5;
e5 = non {negation}e5
    | {terminalexpression}e6;
e6 = parenthesegauche {expression}exp parenthesedroite
    | {variable}var
    | nombre
    | identif parenthesegauche {listeexpression}lexp parenthesedroite
    | lire
    | vrai
    | faux
var = identif
    | identif crochetgauche {expression}exp crochetdroit